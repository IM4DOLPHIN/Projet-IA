# -*- coding: utf-8 -*-
"""projet IRM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e3_UXc0nkbXOZ4dOQbTwX05xbSAeYV2r
"""

# 2.1 Monter Google Drive
from google.colab import drive
drive.mount('/content/drive')

# 2.2 Installer la CLI Kaggle
!pip install kaggle

# 2.3 Copier ton fichier kaggle.json (clé API) depuis Drive
!mkdir -p ~/.kaggle
!cp /content/drive/MyDrive/kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# 3.1 Télécharger le dataset depuis Kaggle
!kaggle datasets download -d navoneel/brain-mri-images-for-brain-tumor-detection -p /content

# 3.2 Dézipper l’archive dans un dossier
!unzip /content/brain-mri-images-for-brain-tumor-detection.zip -d /content/brain_tumor_dataset

import os
print(os.listdir('/content/brain_tumor_dataset'))

# 1.2 Charger toutes les images et construire X, y
import cv2
import numpy as np
from glob import glob

# Récupérer les chemins
yes_paths = glob('/content/brain_tumor_dataset/yes/*.jpg')
no_paths  = glob('/content/brain_tumor_dataset/no/*.jpg')

print("Nombre d'IRM avec tumeur :", len(yes_paths))
print("Nombre d'IRM sans tumeur  :", len(no_paths))

# Charger et redimensionner
X, y = [], []
for p in yes_paths:
    img = cv2.imread(p, cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, (128,128))
    X.append(img); y.append(1)
for p in no_paths:
    img = cv2.imread(p, cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, (128,128))
    X.append(img); y.append(0)

X = np.array(X)
y = np.array(y)
print("Shape de X :", X.shape)
print("Shape de y :", y.shape)

# 1.3 Afficher quelques exemples aléatoires
import matplotlib.pyplot as plt
import random

plt.figure(figsize=(10,4))
for i, idx in enumerate(random.sample(range(len(X)), 10)):
    plt.subplot(2,5,i+1)
    plt.imshow(X[idx], cmap='gray')
    plt.title("Tumeur" if y[idx]==1 else "Normal")
    plt.axis('off')
plt.suptitle("Exemples d'images IRM")
plt.tight_layout()
plt.show()

# 1.4 Distribution des classes
import seaborn as sns

sns.countplot(x=y)
plt.xticks([0,1], ['Normal','Tumeur'])
plt.title("Répartition des images par classe")
plt.show()

from sklearn.model_selection import train_test_split

# on reshape X pour ajouter la dimension « canal »
X = X.reshape(-1, 128, 128, 1)

# split 80% train, 20% test
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.20, stratify=y, random_state=42
)

print("Train :", X_train.shape, y_train.shape)
print("Test  :", X_test.shape,  y_test.shape)

import tensorflow as tf

model = tf.keras.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(128,128,1)),
    tf.keras.layers.MaxPooling2D((2,2)),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D((2,2)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

model.compile(
    optimizer='adam',
    loss='binary_crossentropy',
    metrics=['accuracy']
)

model.summary()

history = model.fit(
    X_train, y_train,
    epochs=10,
    batch_size=16,
    validation_split=0.1  # 10% des données d'entraînement pour val
)

loss, acc = model.evaluate(X_test, y_test)
print(f"Test Accuracy: {acc*100:.2f}%")

import matplotlib.pyplot as plt

plt.plot(history.history['accuracy'], label='train_acc')
plt.plot(history.history['val_accuracy'], label='val_acc')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Sauvegarde au format natif
model.save('/content/brain_tumor_model.keras')

#pour recharger plus tard
from tensorflow.keras.models import load_model
model = load_model('/content/brain_tumor_model.keras')

#Fonction de prédiction sur fichier
import numpy as np
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt

def predict_and_show(img_path):
    # Charger et préparer
    img = image.load_img(img_path, color_mode='grayscale', target_size=(128,128))
    arr = image.img_to_array(img)/255.0
    arr = np.expand_dims(arr,0)
    # Prédiction
    p = model.predict(arr)[0][0]
    label = "Tumeur" if p>0.5 else "Normal"
    # Affichage
    plt.imshow(img, cmap='gray')
    plt.title(f"{label} ({p:.2f})")
    plt.axis('off')
    plt.show()

#Teste sur quelques images du dossier yes et no
predict_and_show(yes_paths[0])
predict_and_show(no_paths[0])